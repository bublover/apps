/*
 * Copyright (c) 2016 Intel Corporation.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include "sfc_flash_test.h"

#include <logging/log.h>
#define LOG_MODULE_NAME repeater
#define LOG_LEVEL CONFIG_REPEATER_LOG_LEVEL
LOG_MODULE_DECLARE(LOG_MODULE_NAME);

u8_t buf[] = {
0x08, 0xF4, 0xAC, 0x42, 0x02, 0xFA, 0x01, 0xF2, 0x00, 0xFA, 0x01, 0xFA,
0x08, 0xD9, 0xED, 0x18, 0x09, 0xF1, 0xFF, 0x30, 0x43, 0xD2, 0xAC, 0x42,
0x41, 0xD9, 0xA9, 0xF1, 0x02, 0x09, 0x1D, 0x44, 0x2D, 0x1B, 0x1F, 0xFA,
0x8E, 0xFE, 0xB5, 0xFB, 0xFC, 0xF0, 0x0C, 0xFB, 0x10, 0x55, 0x4E, 0xEA,
0x05, 0x44, 0x00, 0xFB, 0x08, 0xF8, 0xA0, 0x45, 0x07, 0xD9, 0xE4, 0x18,
0x00, 0xF1, 0xFF, 0x35, 0x29, 0xD2, 0xA0, 0x45, 0x27, 0xD9, 0x02, 0x38,
0x1C, 0x44, 0x40, 0xEA, 0x09, 0x40, 0xA4, 0xEB, 0x08, 0x04, 0xA0, 0xFB,
0x02, 0x89, 0x4C, 0x45, 0xC6, 0x46, 0x4D, 0x46, 0x15, 0xD3, 0x12, 0xD0,
0x56, 0xB1, 0xBA, 0xEB, 0x0E, 0x03, 0x64, 0xEB, 0x05, 0x04, 0x04, 0xFA,
0x07, 0xF7, 0xCB, 0x40, 0x1F, 0x43, 0xCC, 0x40, 0x37, 0x60, 0x74, 0x60,
0x03, 0x05, 0x01, 0x38, 0xE4, 0xE7, 0x28, 0x46, 0xD7, 0xE7, 0x40, 0x46,
0x91, 0xE7, 0x81, 0x46, 0xBE, 0xE7, 0x01, 0x46, 0x78, 0xE7, 0x02, 0x38,
0x3C, 0x44, 0x45, 0xE7, 0x08, 0x46, 0x08, 0xE7, 0xA8, 0xF1, 0x02, 0x08,
0x3D, 0x44, 0x2B, 0xE7, 0x70, 0x47, 0x00, 0xBF, 0x30, 0xB5, 0x83, 0xB0,
0x05, 0x46, 0x01, 0xA9, 0x00, 0x79, 0x00, 0xF0, 0x35, 0xF8, 0xAC, 0x68,
0x6F, 0xD2, 0xAB, 0x42, 0x6D, 0xD9, 0x02, 0x38, 0x3D, 0x44, 0xEB, 0x1A,
0x40, 0xEA, 0x01, 0x41, 0x8F, 0xE7, 0xC1, 0xF1, 0x20, 0x07, 0x22, 0xFA,
0x07, 0xF8, 0x8B, 0x40, 0x05, 0xFA, 0x01, 0xF4, 0x48, 0xEA, 0x03, 0x03,
0x20, 0xFA, 0x07, 0xFE, 0x4F, 0xEA, 0x13, 0x4C, 0xFD, 0x40, 0x4E, 0xEA,
0x04, 0x0E, 0xB5, 0xFB, 0xFC, 0xF9, 0x4F, 0xEA, 0x1E, 0x44, 0x0C, 0xFB,
0x19, 0x55, 0x1F, 0xFA, 0x83, 0xF8, 0x44, 0xEA, 0x05, 0x45, 0x09, 0xFB,
0x00, 0x21, 0xBD, 0xE8, 0xF0, 0x87, 0x18, 0x46, 0xF8, 0xE6, 0x90, 0x46,
0xE0, 0xE6, 0xC2, 0x45, 0xEA, 0xD2, 0xB8, 0xEB, 0x02, 0x0E, 0x69, 0xEB,
0x01, 0x9B, 0x1C, 0x44, 0x2B, 0x68, 0x1B, 0x89, 0x1C, 0x44, 0x4F, 0xF0
};

u8_t r_buf[288] = {0};

static int _test_uwp_flash_internel(const struct shell *shell, size_t argc, char **argv)
{
	struct device *flash_dev;

	u16_t i = 0;

	u16_t rst = true;

	int err = shell_cmd_precheck(shell, (argc >= 0), NULL, 0);
	if (err) {
		printf(" %s param error, argc:[%d]", __func__, argc);
		return err;
	}

	printf("\nW25Q32DW SPI flash testing\n\n\n");
	printf("==========================\n");

	flash_dev = device_get_binding(DT_FLASH_DEV_NAME);

	if (!flash_dev) {
		printf("SPI flash driver was not found!\n");
		return -1;
	}

	/* Write protection needs to be disabled in W25Q32DW flash before
	 * each write or erase. This is because the flash component turns
	 * on write protection automatically after completion of write and
	 * erase operations.
	 */

	if (flash_read(flash_dev, FLASH_TEST_REGION_OFFSET, r_buf,
	    sizeof(r_buf)) != 0) {
		printf("   Flash read failed!\n");
		return -1;
	}
	printf("Before Erase/Write Data read :\n");

	for (i = 0; i < 128; i++) {
		printf(" %02x", r_buf[i]);
	}

	printf("\n==========================\n");
	printf("\nTest 1: Flash erase\n");
	flash_write_protection_set(flash_dev, false);
	if (flash_erase(flash_dev,
			FLASH_TEST_REGION_OFFSET,
			FLASH_SECTOR_SIZE) != 0) {
		printf("   Flash erase failed!\n");
	} else {
		printf("   Flash erase succeeded!\n");
	}
	flash_write_protection_set(flash_dev, true);

	printf("\nTest 2: Flash write\n");
	flash_write_protection_set(flash_dev, false);
	printf("   Attempted to write %x %x\n", buf[0], buf[1]);
	if (flash_write(flash_dev, FLASH_TEST_REGION_OFFSET, buf,
	    sizeof(buf)) != 0) {
		printf("   Flash write failed!\n");
		flash_write_protection_set(flash_dev, true);
		return -1;
	}
	flash_write_protection_set(flash_dev, true);

	printf("\n==========================\n");
	if (flash_read(flash_dev, FLASH_TEST_REGION_OFFSET, r_buf,
	    sizeof(r_buf)) != 0) {
		printf("   Flash read failed!\n");
		return -1;
	}
	printf("After Erase/Write Data read :\n");

	for (i = 0; i < 128; i++) {
		printf(" %02x", r_buf[i]);
	}

	printf("\n");

	for (i = 0; i < 288; i++) {
		if (buf[i] != r_buf[i]) {
			printf("   Data read does not "
				"match with data written!!,"
				" buf[%d]:[%02x], r_buf[%d]:[%02x]\n",
				i, buf[i], i, r_buf[i]);
			
			rst = false;
		}
	}

	printf(" Date read match action end , and rst:[%u]\n\n", rst);
	if (rst)
	{
		printf("   Data read matches with data written. Good!!\n");
	}
	else
	{
		printf("   Data read not matches with data written. Bad!!\n");
	}

	printf("==========================\n\n");
	return 0;
}

SHELL_CREATE_STATIC_SUBCMD_SET(sfc_flash_cmd)
{
	SHELL_CMD(test_sfc, NULL,
	"simple demo for test sfc flash.\n"
	"Usage: test_sfc",
	_test_uwp_flash_internel),
	SHELL_SUBCMD_SET_END /* Array terminated. */
};

/* Creating root (level 0) command "sfc" */
SHELL_CMD_REGISTER(sfc, &sfc_flash_cmd, "test sfc flash", NULL);
